'''
This file handles parsing of HTK-compatible .inf files (such as those generated by HTS/OpenMARY into a python structure.

This should be used in conjunction with the tree_draw module to visualise the question tree.
'''
import sys

###
# LoadTree(file)
# This function parses a HTK formatted tree file, and returns a data structure with the following format:
# DATA
#       [STATE] 
#           [QS NUMBER]
#               [QS LHS]
#               [QS RHS]
#               [NEXT QS IF FALSE] (or [MGC OUT] if leaf node)
#               [NEXT QS IF TRUE] (or [MGC OUT] if leaf node)
###
def LoadTree(file,  trickyPhonesFile):
    f = open(file)
    raw = f.read()
    f.close()
    data = raw.split("\n\n")
    data.pop(0)
    data.pop()
    for i in range(len(data)):
        data[i] = data[i].split("\n")
        
        data[i].pop(0)
        data[i].pop(0)
        data[i].pop()
        
        for j in range(len(data[i])):
            data[i][j] = data[i][j].replace("\t\t","\t")
            data[i][j] = data[i][j].split("\t")
            temp = data[i][j][0].split()[1].split("=")
            data[i][j].pop(0)
            data[i][j].insert(0, temp[0])
            data[i][j].insert(1, temp[1])
            for k in range(2, 4):
                data[i][j][k] = data[i][j][k].replace("-","")
                data[i][j][k] = data[i][j][k].replace("\"","")
                if data[i][j][k].isdigit():
                    data[i][j][k] = int(data[i][j][k])
     
     # Two empty arrays added to start of array, because technically, the first state is state 2
    data.insert(0, [])
    data.insert(0, [])
    trickyPhones = GetTrickyPhones(trickyPhonesFile)
    for i in range(2, len(data)):
        for j in range(len(data[i])):
            if "phone" in data[i][j][0]:
                if trickyPhones.has_key(data[i][j][1]):
                    data[i][j][1] = trickyPhones[data[i][j][1]]
    return data


def GetTrickyPhones(trickyPhonesFile):
    f = open(trickyPhonesFile)
    trickyPhones = f.read().split("\n")
    trickyPhonesDict = dict()
    for i in range(1, len(trickyPhones)-1):
        temp = trickyPhones[i].split()
        trickyPhonesDict[temp[1]] = temp[0]
    
    return trickyPhonesDict
###
# GetAllNeafNodes(partial_string, data)
# This function parses the output data from LoadTree tree file, and returns a list of all leaf nodes which match the partial_string (i.e. "mgc")
#   and contain a reference to the output PDF:
# MATCHES
#       [STATE] 
#           [PDF NAME] (Dictionary)
#               [STATE]
#               [QS NUMBER]
#               [INDEX OF LEAF IN ORIGINAL DATA] (References tree structure: 2 = FALSE OUT, 3 = TRUE OUT)
###
def GetAllLeafNodes(partialString,  data):
    matches = []
    matches.append([])
    matches.append([])
    for i in range(2, len(data)):
        matches_state = dict()
        for j in range(len(data[i])):
            for k in range(2, len(data[i][j])):
                if type(data[i][j][k]) is int:
                    continue
                if partialString in data[i][j][k]:
                    match = data[i][j][k]
                    if matches_state.has_key(match):
                        print "Duplicate entry at:\n\tSTATE: ",  i,  "\n\tQS: ",  j ,"\n\tQS OUTPUT: ",  k
                    else:
                        matches_state[match] = [i, j, k]
        
        matches.append(matches_state)
    return matches

###
# GetQSParent(qsNumber, stateData)
# This function gets the parent node of the question at number qsNumber and state stateData.
# The output is in the following format:
#   [GetQSParent]
#       [NUMBER OF PARENT QUESTION]
#       [DECISION (TRUE/FALSE) REQUIRED AT PARENT TO REACH CHILD]
###
def GetQSParent(qsNumber,  stateData):

    for i in range(len(stateData)):            
        for j in range(2,4):
            if stateData[i][j] == qsNumber:
                if j == 2: # FALSE
                    decision = False
                else: #j ==3
                    decision = True
                    
                return [i, decision]

###
# GetQSNumbers(qsNumber, stateData)
# This function recursively gets a list of the questions which lead to the initial input question (incuding the decisions requried at each node to reach node).
# The output is in the following format:
#   [GetQSNumbers]
#       [QS LIST]
#           [GetQSParent]
###
def GetQSNumbers(qsNumber,  stateData):
    parentNode = GetQSParent(qsNumber,  stateData)
    parentQS = parentNode[0]
    if parentQS == 0:
        return [parentNode]
    
    if parentQS == -1:
        return [-1, False]
        
    qsList = GetQSNumbers(parentQS, stateData);
    qsList.append(parentNode)
    return qsList

###
# GetQSListForPDF(qsNumber, stateData)
# This function recursively gets a list of the questions which lead to the initial input question, based on the input PDF.
# The output is in the following format:
#   [GetQSListForPDF]
#       [QS]
#           [QS NUM]
#           [QS LHS]
#           [QS RHS]
#       [QS ANSWER]]
###
def GetQSListForPDF(pdfName,  state,  matches,  data):
    state_matches = matches[state]
    state_data = data[state]
    qs = state_matches[pdfName][1]
  
    qsNumbers = GetQSNumbers(qs,  state_data)
    originalQS = [qs,  True]
    qsNumbers.append([qs,  state_matches[pdfName] [2] is 3]) # Append original, because we start looking at the parent of original node
    
    for i in range(len(qsNumbers)):
        this_qs = state_data[qsNumbers[i][0]]
        qsNumbers[i][0] = [qsNumbers[i][0],  this_qs[0],  this_qs[1]]
        
    return qsNumbers


