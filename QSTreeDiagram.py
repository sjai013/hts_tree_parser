import pydot
import sys

''' QSTreeDiagram
    This class handles the drawing of tree diagrams from .inf (question) files generated by HTS/HTk.
    This requires the following dependencies:
        graphviz
        pydot
    Using pip, the following procedure is recommended for installing the dependencies 
    in Python v2.x (and probably v3.x):
        pip install graphviz
        pip install pyparsing==1.5.7
        pip install pydot
'''

class QSTreeDiagram:

    infPath = ''
    trickyPhonePath = ''
    pdfPrefix = ''
    states = 0 # vector of states initialised in object
    nStates = 0
    treeData = []
    trickyPhones = []
    leafNodes = []
    pdfTrees = dict()

    ''' __init__(self,  infPath,  trickyPhonePath, pdfPrefix,  createTree = True,  state=-1)
        Constructor parses data to generate internal structures representing the question tree diagram.
        The input for state may be:
            left blank (in which case, all states will be parsed)
            a list (in which case, the specified states will be parsed)
            an int (in which case, the specified state will be parsed)
    '''
    def __init__(self,  infPath,  trickyPhonePath, pdfPrefix,  createTree = True,  state=-1):
        # Store local copy of initialising variables
        self.infPath = infPath
        self.trickyPhonePath = trickyPhonePath
        self.pdfPrefix = pdfPrefix

        # Initialise tree structure
        self.__LoadTree(infPath)
        self.__GetTrickyPhones(trickyPhonePath)
        self.__ConvertTrickyPhones(self.trickyPhones,  self.treeData)
        self.__GetAllLeafNodes(pdfPrefix,  self.treeData)
        
        if (createTree == False):
            return
        if state == -1:
            self.states = range(self.nStates)
            for i in range(len(self.states)): self.states[i] += 2            
        elif type(state) is list:
            self.states = state
        else:
            self.states = range(state,  state+1)
        # Iterate through all states and generate tree structure
        for i in self.states:
            this_state = i
            state_leafNodes = self.leafNodes[this_state]
            state_treeData = self.treeData[this_state]
            state_pdfTree = dict()
            # Append two blank elements to keep with state naming convention
            self.pdfTrees[0] = []
            self.pdfTrees[1] = []
            
            sys.stdout.write("Loading feature tree for state: " + str(this_state) + ' ...\n')
            numPDFs = len(state_leafNodes.keys())
            pdfsComplete = 0
            percentComplete = pdfsComplete/numPDFs
            self.__DrawProgress(pdfsComplete)

            for pdfName in state_leafNodes.keys():
                state_pdfTree[pdfName] = self.__GetQSListForPDF(pdfName,  state_leafNodes,  state_treeData)
                pdfsComplete += 1
                percentComplete = float(pdfsComplete)/numPDFs*100
                self.__DrawProgress(percentComplete)                
            
            
            self.pdfTrees[i] = state_pdfTree
            print ''
   

    ''' DrawTree(self, state,  saveAsPath="./image.png"):
        Draw tree diagram for a particular state, and save resultant image at some location
    '''
    def DrawTree(self, state,  saveAsPath="./image.png"):
        graph = pydot.Dot(graph_type='graph')
        questions = self.treeData[state]
        pdfTree = self.pdfTrees[state]
        print 'Generating tree diagram...'
        # Add all questions as nodes 
        for i in range(len(questions)):
            nodeName = "qs%d" %i
            nodeLabel = "%s=%s" %(questions[i][0],  questions[i][1])
            graph.add_node(pydot.Node(nodeName, label=nodeLabel,style="filled", fillcolor="#ffaaaa"))

        # Add all pdfs as nodes
        for pdfName in pdfTree.keys():
            graph.add_node(pydot.Node(pdfName, label=pdfName,  style="filled",  fillcolor="#aaffaa"))

        # Draw edges (could merge this with above loop, but code is more readable this way)
        for pdfName in pdfTree.keys():
            for i in range(len(pdfTree[pdfName])-1):
                # Iterate through all questions for this output PDF, linking n with n+1
                node_this = "qs%d" %pdfTree[pdfName][i][0][0]
                node_next = "qs%d" %pdfTree[pdfName][i+1][0][0]
                qsAnswer = "{}".format(pdfTree[pdfName][i][1])
                edge_key = (node_this, node_next)
                # need to make sure edges doesn't exist, otherwise pydot draws multiple lines which look horrible
                if edge_key not in graph.obj_dict['edges'].keys():
                    edge = pydot.Edge(node_this,  node_next,  label=qsAnswer)
                    graph.add_edge(edge)

            # At end, draw the link between final node and leaf node


            node_this = node_next
            node_next = pdfName
            qsAnswer = "{}".format(pdfTree[pdfName][i+1][1])
            edge = pydot.Edge(node_this,  node_next,  label=qsAnswer)
            graph.add_edge(edge)

        print 'Saving tree diagram to ' + saveAsPath
        graph.write_png(saveAsPath)
        print "File written to " + saveAsPath

    ''' __LoadTree(file)
    # This function parses a HTK formatted tree file, and returns a data structure with the following format:
    # DATA
    #       [STATE] 
    #           [QS NUMBER]
    #               [QS LHS]
    #               [QS RHS]
    #               [NEXT QS IF FALSE] (or [MGC OUT] if leaf node)
    #               [NEXT QS IF TRUE] (or [MGC OUT] if leaf node)
    '''
    def __LoadTree(self, infFile):
        sys.stdout.write( "Loading " + infFile + " ...")
        f = open(infFile)
        raw = f.read()
        f.close()
        data = raw.split("\n\n")
        data.pop(0)
        data.pop()
        for i in range(len(data)):
            data[i] = data[i].split("\n")

            data[i].pop(0)
            data[i].pop(0)
            data[i].pop()

            for j in range(len(data[i])):
                data[i][j] = data[i][j].replace("\t\t","\t")
                data[i][j] = data[i][j].split("\t")
                temp = data[i][j][0].split()[1].split("=")
                data[i][j].pop(0)
                data[i][j].insert(0, temp[0])
                data[i][j].insert(1, temp[1])
                for k in range(2, 4):
                    data[i][j][k] = data[i][j][k].replace("-","")
                    data[i][j][k] = data[i][j][k].replace("\"","")
                    if data[i][j][k].isdigit():
                        data[i][j][k] = int(data[i][j][k])

         # Two empty arrays added to start of array, because technically, the first state is state 2
        data.insert(0, [])
        data.insert(0, [])
        self.treeData = data
        self.nStates = len(self.treeData)-2
        sys.stdout.write("done\n")

    ''' __GetTrickyPhones(self, trickyPhonesFile):
        Get list of tricky phones (i.e. phones which can't be used as text 
        because they consist of a weird character)
    '''

    def __GetTrickyPhones(self, trickyPhonesFile):
        sys.stdout.write ("Getting tricky phones from " + trickyPhonesFile + " ...")
        f = open(trickyPhonesFile)
        _trickyPhones = f.read().split("\n")
        trickyPhones = dict()
        for i in range(1, len(_trickyPhones)-1):
            temp = _trickyPhones[i].split()
            trickyPhones[temp[1]] = temp[0]
        self.trickyPhones = trickyPhones
        sys.stdout.write ("done\n")
        
    ''' __ConvertTrickyPhones(self, trickyPhones, treeData):
        Convert tricky phones to actual phones defined in allophone.xml
    '''
    def __ConvertTrickyPhones(self, trickyPhones, treeData):
        sys.stdout.write("Converting tricky phones back to original phones...")
        for i in range(2, len(treeData)):
            for j in range(len(treeData[i])):
                if "phone" in treeData[i][j][0]:
                    if trickyPhones.has_key(treeData[i][j][1]):
                        treeData[i][j][1] = trickyPhones[treeData[i][j][1]]

        sys.stdout.write("done\n")
        self.treeData = treeData


    ''' __GetAllNeafNodes(partial_string, data)
    # This function parses the output data from LoadTree tree file, and returns a list of all leaf nodes which match the partial_string (i.e. "mgc")
    #   and contain a reference to the output PDF:
    # MATCHES
    #       [STATE] 
    #           [PDF NAME] (Dictionary)
    #               [STATE]
    #               [QS NUMBER]
    #               [INDEX OF LEAF IN ORIGINAL DATA] (References tree structure: 2 = FALSE OUT, 3 = TRUE OUT)
    '''
    def __GetAllLeafNodes(self, partialString,  data):
        sys.stdout.write("Getting list of leaf nodes matching string [" + partialString + "]...")
        matches = []
        matches.append([])
        matches.append([])
        for i in range(2, len(data)):
            matches_state = dict()
            for j in range(len(data[i])):
                for k in range(2, len(data[i][j])):
                    if type(data[i][j][k]) is int:
                        continue
                    if partialString in data[i][j][k]:
                        match = data[i][j][k]
                        if matches_state.has_key(match):
                            print "Duplicate entry at:\n\tSTATE: ",  i,  "\n\tQS: ",  j ,"\n\tQS OUTPUT: ",  k
                        else:
                            matches_state[match] = [i, j, k]

            matches.append(matches_state)

        self.leafNodes = matches
        sys.stdout.write("done\n")
        


    ''' GetQSParent(qsNumber, state_treeData)
    # This function gets the parent node of the question at number qsNumber and state stateData.
    # The output is in the following format:
    #   [GetQSParent]
    #       [NUMBER OF PARENT QUESTION]
    #       [DECISION (TRUE/FALSE) REQUIRED AT PARENT TO REACH CHILD]
    '''
    def __GetQSParent(self, qsNumber,  state_treeData):

        for i in range(len(state_treeData)):            
            for j in range(2,4):
                if state_treeData[i][j] == qsNumber:
                    if j == 2: # FALSE
                        decision = False
                    else: #j ==3
                        decision = True

                    return [i, decision]

    ''' __GetQSNumbers(qsNumber, state_treeData)
    # This function recursively gets a list of the questions which lead to the initial input question (incuding the decisions requried at each node to reach node).
    # The output is in the following format:
    #   [GetQSNumbers]
    #       [QS LIST]
    #           [GetQSParent]
    '''
    def __GetQSNumbers(self, qsNumber,  state_treeData):
        parentNode = self.__GetQSParent(qsNumber,  state_treeData)
        parentQS = parentNode[0]
        if parentQS == 0:
            return [parentNode]

        if parentQS == -1:
            return [-1, False]

        qsList = self.__GetQSNumbers(parentQS, state_treeData);
        qsList.append(parentNode)
        return qsList

    ''' __GetQSListForPDF(qsNumber, stateData)
    # This function recursively gets a list of the questions which lead to the initial input question, based on the input PDF.
    # The output is in the following format:
    #   [GetQSListForPDF]
    #       [QS]
    #           [QS NUM]
    #           [QS LHS]
    #           [QS RHS]
    #       [QS ANSWER]]
    '''
    def __GetQSListForPDF(self, pdfName,  state_leafNodes, state_treeData):
        qs = state_leafNodes[pdfName][1]
        qsNumbers = self.__GetQSNumbers(qs,  state_treeData)
        originalQS = [qs,  True]
        qsNumbers.append([qs,  state_leafNodes[pdfName] [2] is 3]) # Append original, because we start looking at the parent of original node

        for i in range(len(qsNumbers)):
            this_qs = state_treeData[qsNumbers[i][0]]
            qsNumbers[i][0] = [qsNumbers[i][0],  this_qs[0],  this_qs[1]]

        return qsNumbers

    ''' __DrawProgress(self, percentComplete)
        Draw progress bar
    '''
    def __DrawProgress(self, percentComplete):
        sys.stdout.write('\r')
        sys.stdout.write("[%-20s] %d%%" % ('='*int(percentComplete/5), percentComplete))
        sys.stdout.flush()
